// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: queues/topology/cloud/cloud.proto

package cloud

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CloudType represents the different clouds
type CloudType int32

const (
	UnknownCloudType CloudType = 0
	AWS              CloudType = 1
	Azure            CloudType = 2
	GCP              CloudType = 3
	IBM              CloudType = 4
)

var CloudType_name = map[int32]string{
	0: "UnknownCloudType",
	1: "AWS",
	2: "Azure",
	3: "GCP",
	4: "IBM",
}

var CloudType_value = map[string]int32{
	"UnknownCloudType": 0,
	"AWS":              1,
	"Azure":            2,
	"GCP":              3,
	"IBM":              4,
}

func (CloudType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_70a5df8d43273b32, []int{0}
}

// CloudEntityType represents the different types of entities we sample traffic for
type CloudEntityType int32

const (
	UnknownEntityType CloudEntityType = 0
	Region            CloudEntityType = 1
	VPC               CloudEntityType = 2
	Subnet            CloudEntityType = 3
	VM                CloudEntityType = 4
)

var CloudEntityType_name = map[int32]string{
	0: "UnknownEntityType",
	1: "Region",
	2: "VPC",
	3: "Subnet",
	4: "VM",
}

var CloudEntityType_value = map[string]int32{
	"UnknownEntityType": 0,
	"Region":            1,
	"VPC":               2,
	"Subnet":            3,
	"VM":                4,
}

func (CloudEntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_70a5df8d43273b32, []int{1}
}

// ByteCount holds number of bytes in/out from a traffic sample
type ByteCount struct {
	// Out holds how many bytes the source has sent out to the destination
	Out uint64 `protobuf:"varint,1,opt,name=Out,json=out,proto3" json:"Out,omitempty"`
	// In holds how many bytes the source has received from the destination
	In uint64 `protobuf:"varint,2,opt,name=In,json=in,proto3" json:"In,omitempty"`
	// FlowCount holds how many flows received for this communication
	FlowCount uint64 `protobuf:"varint,3,opt,name=FlowCount,json=flowCount,proto3" json:"FlowCount,omitempty"`
}

func (m *ByteCount) Reset()      { *m = ByteCount{} }
func (*ByteCount) ProtoMessage() {}
func (*ByteCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_70a5df8d43273b32, []int{0}
}
func (m *ByteCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ByteCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ByteCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ByteCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ByteCount.Merge(m, src)
}
func (m *ByteCount) XXX_Size() int {
	return m.Size()
}
func (m *ByteCount) XXX_DiscardUnknown() {
	xxx_messageInfo_ByteCount.DiscardUnknown(m)
}

var xxx_messageInfo_ByteCount proto.InternalMessageInfo

func (m *ByteCount) GetOut() uint64 {
	if m != nil {
		return m.Out
	}
	return 0
}

func (m *ByteCount) GetIn() uint64 {
	if m != nil {
		return m.In
	}
	return 0
}

func (m *ByteCount) GetFlowCount() uint64 {
	if m != nil {
		return m.FlowCount
	}
	return 0
}

// CloudHierarchy represents a found hierarchy of region, vpc, subnet, VM instance
// values are tagLookupIDs, since this is how they're received in chfclient
type CloudHierarchy struct {
	// Region represented by uint32 tag lookup (populator value)
	Region uint32 `protobuf:"varint,1,opt,name=Region,json=region,proto3" json:"Region,omitempty"`
	// VPC represented by uint32 tag lookup (populator value)
	VPC uint32 `protobuf:"varint,2,opt,name=VPC,json=vPC,proto3" json:"VPC,omitempty"`
	// Subnet represented by uint32 tag lookup (populator value)
	Subnet uint32 `protobuf:"varint,3,opt,name=Subnet,json=subnet,proto3" json:"Subnet,omitempty"`
	// VMInstance represented by uint32 tag lookup (populator value)
	VMInstance uint32 `protobuf:"varint,4,opt,name=VMInstance,json=vMInstance,proto3" json:"VMInstance,omitempty"`
	// Region represented by string, used when we don't have a uint32 tag lookup populator for it
	RegionStr string `protobuf:"bytes,5,opt,name=RegionStr,json=regionStr,proto3" json:"RegionStr,omitempty"`
	// VPC represented by string, used when we don't have a uint32 tag lookup populator for it
	VPCStr string `protobuf:"bytes,6,opt,name=VPCStr,json=vPCStr,proto3" json:"VPCStr,omitempty"`
	// Subnet represented by string, used when we don't have a uint32 tag lookup populator for it
	SubnetStr string `protobuf:"bytes,7,opt,name=SubnetStr,json=subnetStr,proto3" json:"SubnetStr,omitempty"`
	// VMInstance represented by string, used when we don't have a uint32 tag lookup populator for it
	VMInstanceStr string `protobuf:"bytes,8,opt,name=VMInstanceStr,json=vMInstanceStr,proto3" json:"VMInstanceStr,omitempty"`
}

func (m *CloudHierarchy) Reset()      { *m = CloudHierarchy{} }
func (*CloudHierarchy) ProtoMessage() {}
func (*CloudHierarchy) Descriptor() ([]byte, []int) {
	return fileDescriptor_70a5df8d43273b32, []int{1}
}
func (m *CloudHierarchy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudHierarchy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudHierarchy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudHierarchy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudHierarchy.Merge(m, src)
}
func (m *CloudHierarchy) XXX_Size() int {
	return m.Size()
}
func (m *CloudHierarchy) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudHierarchy.DiscardUnknown(m)
}

var xxx_messageInfo_CloudHierarchy proto.InternalMessageInfo

func (m *CloudHierarchy) GetRegion() uint32 {
	if m != nil {
		return m.Region
	}
	return 0
}

func (m *CloudHierarchy) GetVPC() uint32 {
	if m != nil {
		return m.VPC
	}
	return 0
}

func (m *CloudHierarchy) GetSubnet() uint32 {
	if m != nil {
		return m.Subnet
	}
	return 0
}

func (m *CloudHierarchy) GetVMInstance() uint32 {
	if m != nil {
		return m.VMInstance
	}
	return 0
}

func (m *CloudHierarchy) GetRegionStr() string {
	if m != nil {
		return m.RegionStr
	}
	return ""
}

func (m *CloudHierarchy) GetVPCStr() string {
	if m != nil {
		return m.VPCStr
	}
	return ""
}

func (m *CloudHierarchy) GetSubnetStr() string {
	if m != nil {
		return m.SubnetStr
	}
	return ""
}

func (m *CloudHierarchy) GetVMInstanceStr() string {
	if m != nil {
		return m.VMInstanceStr
	}
	return ""
}

// CloudTrafficSample represents traffic summary between a source entity and all its dest entities
type CloudTrafficSample struct {
	// window start time, in unix epoch seconds
	WindowStartUnixSeconds int64 `protobuf:"varint,1,opt,name=WindowStartUnixSeconds,json=windowStartUnixSeconds,proto3" json:"WindowStartUnixSeconds,omitempty"`
	// windoe end time, in unix epoch seconds
	WindowEndUnixSeconds int64 `protobuf:"varint,2,opt,name=WindowEndUnixSeconds,json=windowEndUnixSeconds,proto3" json:"WindowEndUnixSeconds,omitempty"`
	// which cloud entity type this message represents
	CloudEntityType CloudEntityType `protobuf:"varint,3,opt,name=CloudEntityType,json=cloudEntityType,proto3,enum=cloud.CloudEntityType" json:"CloudEntityType,omitempty"`
	// SourceEntity holds the name (referred to by uint64 string lookup) of the source entity (region, vpc, subnet, VM, etc)
	SourceEntity uint32 `protobuf:"varint,4,opt,name=SourceEntity,json=sourceEntity,proto3" json:"SourceEntity,omitempty"`
	// ByteCounts holds how many bytes in/out we have for each destination entity
	ByteCounts map[uint32]ByteCount `protobuf:"bytes,5,rep,name=ByteCounts,json=byteCounts,proto3" json:"ByteCounts" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// LocalLookups is used for string fields that don't have tag lookups.
	LocalLookups map[uint32]string `protobuf:"bytes,6,rep,name=LocalLookups,json=localLookups,proto3" json:"LocalLookups" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CloudTrafficSample) Reset()      { *m = CloudTrafficSample{} }
func (*CloudTrafficSample) ProtoMessage() {}
func (*CloudTrafficSample) Descriptor() ([]byte, []int) {
	return fileDescriptor_70a5df8d43273b32, []int{2}
}
func (m *CloudTrafficSample) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudTrafficSample) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudTrafficSample.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudTrafficSample) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudTrafficSample.Merge(m, src)
}
func (m *CloudTrafficSample) XXX_Size() int {
	return m.Size()
}
func (m *CloudTrafficSample) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudTrafficSample.DiscardUnknown(m)
}

var xxx_messageInfo_CloudTrafficSample proto.InternalMessageInfo

func (m *CloudTrafficSample) GetWindowStartUnixSeconds() int64 {
	if m != nil {
		return m.WindowStartUnixSeconds
	}
	return 0
}

func (m *CloudTrafficSample) GetWindowEndUnixSeconds() int64 {
	if m != nil {
		return m.WindowEndUnixSeconds
	}
	return 0
}

func (m *CloudTrafficSample) GetCloudEntityType() CloudEntityType {
	if m != nil {
		return m.CloudEntityType
	}
	return UnknownEntityType
}

func (m *CloudTrafficSample) GetSourceEntity() uint32 {
	if m != nil {
		return m.SourceEntity
	}
	return 0
}

func (m *CloudTrafficSample) GetByteCounts() map[uint32]ByteCount {
	if m != nil {
		return m.ByteCounts
	}
	return nil
}

func (m *CloudTrafficSample) GetLocalLookups() map[uint32]string {
	if m != nil {
		return m.LocalLookups
	}
	return nil
}

func init() {
	proto.RegisterEnum("cloud.CloudType", CloudType_name, CloudType_value)
	proto.RegisterEnum("cloud.CloudEntityType", CloudEntityType_name, CloudEntityType_value)
	proto.RegisterType((*ByteCount)(nil), "cloud.ByteCount")
	proto.RegisterType((*CloudHierarchy)(nil), "cloud.CloudHierarchy")
	proto.RegisterType((*CloudTrafficSample)(nil), "cloud.CloudTrafficSample")
	proto.RegisterMapType((map[uint32]ByteCount)(nil), "cloud.CloudTrafficSample.ByteCountsEntry")
	proto.RegisterMapType((map[uint32]string)(nil), "cloud.CloudTrafficSample.LocalLookupsEntry")
}

func init() { proto.RegisterFile("queues/topology/cloud/cloud.proto", fileDescriptor_70a5df8d43273b32) }

var fileDescriptor_70a5df8d43273b32 = []byte{
	// 659 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0xcf, 0x6f, 0x12, 0x41,
	0x14, 0xde, 0xd9, 0x85, 0xad, 0xfb, 0x0a, 0xed, 0x76, 0x82, 0x84, 0x34, 0x66, 0xac, 0xc4, 0x98,
	0x5a, 0x23, 0x24, 0x68, 0x8c, 0xf1, 0xa2, 0x85, 0xd4, 0xda, 0xd8, 0xa6, 0xb8, 0xb4, 0xf4, 0x0c,
	0xcb, 0x40, 0x37, 0xa5, 0x33, 0xb8, 0x3b, 0x0b, 0xe2, 0xc9, 0x3f, 0xc1, 0x3f, 0xc1, 0xa3, 0x7f,
	0x4a, 0x8f, 0x3d, 0xf6, 0x64, 0xec, 0xf6, 0xe2, 0xc1, 0x43, 0xff, 0x04, 0x33, 0xb3, 0x40, 0xb7,
	0x3f, 0xbc, 0x90, 0x79, 0xdf, 0xf7, 0xbe, 0xef, 0x9b, 0x79, 0x3c, 0x80, 0x47, 0x9f, 0x43, 0x1a,
	0xd2, 0xa0, 0x2c, 0xf8, 0x80, 0xf7, 0x79, 0x6f, 0x5c, 0x76, 0xfb, 0x3c, 0xec, 0xc4, 0x9f, 0xa5,
	0x81, 0xcf, 0x05, 0xc7, 0x69, 0x55, 0x2c, 0x3f, 0xef, 0x79, 0xe2, 0x30, 0x6c, 0x97, 0x5c, 0x7e,
	0x5c, 0xee, 0xf1, 0x1e, 0x2f, 0x2b, 0xb6, 0x1d, 0x76, 0x55, 0xa5, 0x0a, 0x75, 0x8a, 0x55, 0xc5,
	0x8f, 0x60, 0x55, 0xc7, 0x82, 0xd6, 0x78, 0xc8, 0x04, 0xb6, 0xc1, 0xd8, 0x0d, 0x45, 0x01, 0xad,
	0xa0, 0xd5, 0x94, 0x63, 0xf0, 0x50, 0xe0, 0x05, 0xd0, 0xb7, 0x58, 0x41, 0x57, 0x80, 0xee, 0x31,
	0xfc, 0x00, 0xac, 0xf7, 0x7d, 0x3e, 0x52, 0xed, 0x05, 0x43, 0xc1, 0x56, 0x77, 0x0a, 0x14, 0xff,
	0x22, 0x58, 0xa8, 0xc9, 0x5b, 0x7c, 0xf0, 0xa8, 0xdf, 0xf2, 0xdd, 0xc3, 0x31, 0xce, 0x83, 0xe9,
	0xd0, 0x9e, 0xc7, 0x99, 0x72, 0xcd, 0x3a, 0xa6, 0xaf, 0x2a, 0x19, 0xd5, 0xac, 0xd7, 0x94, 0x73,
	0xd6, 0x31, 0x86, 0xf5, 0x9a, 0xec, 0x6c, 0x84, 0x6d, 0x46, 0x63, 0xdf, 0xac, 0x63, 0x06, 0xaa,
	0xc2, 0x04, 0xa0, 0xb9, 0xb3, 0xc5, 0x02, 0xd1, 0x62, 0x2e, 0x2d, 0xa4, 0x14, 0x07, 0xc3, 0x19,
	0x22, 0xaf, 0x14, 0x27, 0x34, 0x84, 0x5f, 0x48, 0xaf, 0xa0, 0x55, 0xcb, 0xb1, 0xfc, 0x29, 0x20,
	0x5d, 0x9b, 0xf5, 0x9a, 0xa4, 0x4c, 0x45, 0x99, 0x43, 0x55, 0x49, 0x55, 0x9c, 0x26, 0xa9, 0xb9,
	0x58, 0x15, 0x4c, 0x01, 0xfc, 0x18, 0xb2, 0x57, 0x99, 0xb2, 0xe3, 0x9e, 0xea, 0xc8, 0x0e, 0x93,
	0x60, 0xf1, 0x47, 0x0a, 0xb0, 0x7a, 0xee, 0x9e, 0xdf, 0xea, 0x76, 0x3d, 0xb7, 0xd1, 0x3a, 0x1e,
	0xf4, 0x29, 0x7e, 0x05, 0xf9, 0x03, 0x8f, 0x75, 0xf8, 0xa8, 0x21, 0x5a, 0xbe, 0xd8, 0x67, 0xde,
	0x97, 0x06, 0x75, 0x39, 0xeb, 0x04, 0x6a, 0x04, 0x86, 0x93, 0x1f, 0xdd, 0xc9, 0xe2, 0x0a, 0xe4,
	0x62, 0xdd, 0x06, 0xeb, 0x24, 0x55, 0xba, 0x52, 0xe5, 0x46, 0x77, 0x70, 0xf8, 0x1d, 0x2c, 0xaa,
	0x1b, 0x6c, 0x30, 0xe1, 0x89, 0xf1, 0xde, 0x78, 0x40, 0xd5, 0xf4, 0x16, 0x2a, 0xf9, 0x52, 0xbc,
	0x1b, 0x37, 0x58, 0x67, 0xd1, 0xbd, 0x0e, 0xe0, 0x22, 0x64, 0x1a, 0x3c, 0xf4, 0x5d, 0x1a, 0x63,
	0x93, 0x01, 0x67, 0x82, 0x04, 0x86, 0x77, 0x01, 0x66, 0x4b, 0x12, 0x14, 0xd2, 0x2b, 0xc6, 0xea,
	0x7c, 0xe5, 0x69, 0x32, 0xe0, 0xda, 0x00, 0x4a, 0x57, 0xbd, 0x1b, 0x4c, 0xf8, 0xe3, 0x6a, 0xea,
	0xe4, 0xd7, 0x43, 0xcd, 0x81, 0xf6, 0x0c, 0xc6, 0xfb, 0x90, 0xd9, 0xe6, 0x6e, 0xab, 0xbf, 0xcd,
	0xf9, 0x51, 0x38, 0x08, 0x0a, 0xa6, 0xb2, 0x7c, 0xf6, 0x7f, 0xcb, 0x64, 0x77, 0xd2, 0x34, 0xd3,
	0x4f, 0x10, 0xcb, 0xbb, 0xb0, 0x78, 0x23, 0x5b, 0xee, 0xd9, 0x11, 0x1d, 0x4f, 0x96, 0x4f, 0x1e,
	0xf1, 0x13, 0x48, 0x0f, 0x5b, 0xfd, 0x90, 0xaa, 0xb9, 0xce, 0x57, 0xec, 0x49, 0xe8, 0x4c, 0xe8,
	0xc4, 0xf4, 0x1b, 0xfd, 0x35, 0x5a, 0x7e, 0x0b, 0x4b, 0xb7, 0x92, 0xef, 0xb0, 0xcc, 0x25, 0x2d,
	0xad, 0x84, 0xc1, 0xda, 0x26, 0x58, 0xf1, 0x6b, 0xe4, 0xa8, 0x73, 0x60, 0xef, 0xb3, 0x23, 0xc6,
	0x47, 0x6c, 0x86, 0xd9, 0x1a, 0x9e, 0x03, 0x63, 0xfd, 0xa0, 0x61, 0x23, 0x6c, 0x41, 0x7a, 0xfd,
	0x6b, 0xe8, 0x53, 0x5b, 0x97, 0xd8, 0x66, 0xad, 0x6e, 0x1b, 0xf2, 0xb0, 0x55, 0xdd, 0xb1, 0x53,
	0x6b, 0x9f, 0x6e, 0x7d, 0xd1, 0xf8, 0x3e, 0x2c, 0x4d, 0xec, 0xae, 0x40, 0x5b, 0xc3, 0x30, 0xfd,
	0xc5, 0xd9, 0x48, 0xca, 0x9b, 0xf5, 0x9a, 0xad, 0x4b, 0x30, 0x5e, 0x77, 0xdb, 0xc0, 0x26, 0xe8,
	0xcd, 0x1d, 0x3b, 0x55, 0x7d, 0x79, 0x7a, 0x4e, 0xb4, 0xb3, 0x73, 0xa2, 0x5d, 0x9e, 0x13, 0xf4,
	0x2d, 0x22, 0xe8, 0x67, 0x44, 0xd0, 0x49, 0x44, 0xd0, 0x69, 0x44, 0xd0, 0xef, 0x88, 0xa0, 0x3f,
	0x11, 0xd1, 0x2e, 0x23, 0x82, 0xbe, 0x5f, 0x10, 0xed, 0xf4, 0x82, 0x68, 0x67, 0x17, 0x44, 0x6b,
	0x9b, 0xea, 0x7f, 0xe3, 0xc5, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xdc, 0xd3, 0x22, 0x8c, 0x92,
	0x04, 0x00, 0x00,
}

func (x CloudType) String() string {
	s, ok := CloudType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CloudEntityType) String() string {
	s, ok := CloudEntityType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ByteCount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ByteCount)
	if !ok {
		that2, ok := that.(ByteCount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Out != that1.Out {
		return false
	}
	if this.In != that1.In {
		return false
	}
	if this.FlowCount != that1.FlowCount {
		return false
	}
	return true
}
func (this *CloudHierarchy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudHierarchy)
	if !ok {
		that2, ok := that.(CloudHierarchy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.VPC != that1.VPC {
		return false
	}
	if this.Subnet != that1.Subnet {
		return false
	}
	if this.VMInstance != that1.VMInstance {
		return false
	}
	if this.RegionStr != that1.RegionStr {
		return false
	}
	if this.VPCStr != that1.VPCStr {
		return false
	}
	if this.SubnetStr != that1.SubnetStr {
		return false
	}
	if this.VMInstanceStr != that1.VMInstanceStr {
		return false
	}
	return true
}
func (this *CloudTrafficSample) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudTrafficSample)
	if !ok {
		that2, ok := that.(CloudTrafficSample)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WindowStartUnixSeconds != that1.WindowStartUnixSeconds {
		return false
	}
	if this.WindowEndUnixSeconds != that1.WindowEndUnixSeconds {
		return false
	}
	if this.CloudEntityType != that1.CloudEntityType {
		return false
	}
	if this.SourceEntity != that1.SourceEntity {
		return false
	}
	if len(this.ByteCounts) != len(that1.ByteCounts) {
		return false
	}
	for i := range this.ByteCounts {
		a := this.ByteCounts[i]
		b := that1.ByteCounts[i]
		if !(&a).Equal(&b) {
			return false
		}
	}
	if len(this.LocalLookups) != len(that1.LocalLookups) {
		return false
	}
	for i := range this.LocalLookups {
		if this.LocalLookups[i] != that1.LocalLookups[i] {
			return false
		}
	}
	return true
}
func (this *ByteCount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud.ByteCount{")
	s = append(s, "Out: "+fmt.Sprintf("%#v", this.Out)+",\n")
	s = append(s, "In: "+fmt.Sprintf("%#v", this.In)+",\n")
	s = append(s, "FlowCount: "+fmt.Sprintf("%#v", this.FlowCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudHierarchy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&cloud.CloudHierarchy{")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "VPC: "+fmt.Sprintf("%#v", this.VPC)+",\n")
	s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	s = append(s, "VMInstance: "+fmt.Sprintf("%#v", this.VMInstance)+",\n")
	s = append(s, "RegionStr: "+fmt.Sprintf("%#v", this.RegionStr)+",\n")
	s = append(s, "VPCStr: "+fmt.Sprintf("%#v", this.VPCStr)+",\n")
	s = append(s, "SubnetStr: "+fmt.Sprintf("%#v", this.SubnetStr)+",\n")
	s = append(s, "VMInstanceStr: "+fmt.Sprintf("%#v", this.VMInstanceStr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudTrafficSample) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud.CloudTrafficSample{")
	s = append(s, "WindowStartUnixSeconds: "+fmt.Sprintf("%#v", this.WindowStartUnixSeconds)+",\n")
	s = append(s, "WindowEndUnixSeconds: "+fmt.Sprintf("%#v", this.WindowEndUnixSeconds)+",\n")
	s = append(s, "CloudEntityType: "+fmt.Sprintf("%#v", this.CloudEntityType)+",\n")
	s = append(s, "SourceEntity: "+fmt.Sprintf("%#v", this.SourceEntity)+",\n")
	keysForByteCounts := make([]uint32, 0, len(this.ByteCounts))
	for k, _ := range this.ByteCounts {
		keysForByteCounts = append(keysForByteCounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForByteCounts)
	mapStringForByteCounts := "map[uint32]ByteCount{"
	for _, k := range keysForByteCounts {
		mapStringForByteCounts += fmt.Sprintf("%#v: %#v,", k, this.ByteCounts[k])
	}
	mapStringForByteCounts += "}"
	if this.ByteCounts != nil {
		s = append(s, "ByteCounts: "+mapStringForByteCounts+",\n")
	}
	keysForLocalLookups := make([]uint32, 0, len(this.LocalLookups))
	for k, _ := range this.LocalLookups {
		keysForLocalLookups = append(keysForLocalLookups, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForLocalLookups)
	mapStringForLocalLookups := "map[uint32]string{"
	for _, k := range keysForLocalLookups {
		mapStringForLocalLookups += fmt.Sprintf("%#v: %#v,", k, this.LocalLookups[k])
	}
	mapStringForLocalLookups += "}"
	if this.LocalLookups != nil {
		s = append(s, "LocalLookups: "+mapStringForLocalLookups+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCloud(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ByteCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByteCount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ByteCount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlowCount != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.FlowCount))
		i--
		dAtA[i] = 0x18
	}
	if m.In != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.In))
		i--
		dAtA[i] = 0x10
	}
	if m.Out != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.Out))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloudHierarchy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudHierarchy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudHierarchy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VMInstanceStr) > 0 {
		i -= len(m.VMInstanceStr)
		copy(dAtA[i:], m.VMInstanceStr)
		i = encodeVarintCloud(dAtA, i, uint64(len(m.VMInstanceStr)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SubnetStr) > 0 {
		i -= len(m.SubnetStr)
		copy(dAtA[i:], m.SubnetStr)
		i = encodeVarintCloud(dAtA, i, uint64(len(m.SubnetStr)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VPCStr) > 0 {
		i -= len(m.VPCStr)
		copy(dAtA[i:], m.VPCStr)
		i = encodeVarintCloud(dAtA, i, uint64(len(m.VPCStr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RegionStr) > 0 {
		i -= len(m.RegionStr)
		copy(dAtA[i:], m.RegionStr)
		i = encodeVarintCloud(dAtA, i, uint64(len(m.RegionStr)))
		i--
		dAtA[i] = 0x2a
	}
	if m.VMInstance != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.VMInstance))
		i--
		dAtA[i] = 0x20
	}
	if m.Subnet != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.Subnet))
		i--
		dAtA[i] = 0x18
	}
	if m.VPC != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.VPC))
		i--
		dAtA[i] = 0x10
	}
	if m.Region != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.Region))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloudTrafficSample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudTrafficSample) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudTrafficSample) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalLookups) > 0 {
		for k := range m.LocalLookups {
			v := m.LocalLookups[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloud(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintCloud(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCloud(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ByteCounts) > 0 {
		for k := range m.ByteCounts {
			v := m.ByteCounts[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloud(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintCloud(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCloud(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SourceEntity != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.SourceEntity))
		i--
		dAtA[i] = 0x20
	}
	if m.CloudEntityType != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.CloudEntityType))
		i--
		dAtA[i] = 0x18
	}
	if m.WindowEndUnixSeconds != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.WindowEndUnixSeconds))
		i--
		dAtA[i] = 0x10
	}
	if m.WindowStartUnixSeconds != 0 {
		i = encodeVarintCloud(dAtA, i, uint64(m.WindowStartUnixSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCloud(dAtA []byte, offset int, v uint64) int {
	offset -= sovCloud(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ByteCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Out != 0 {
		n += 1 + sovCloud(uint64(m.Out))
	}
	if m.In != 0 {
		n += 1 + sovCloud(uint64(m.In))
	}
	if m.FlowCount != 0 {
		n += 1 + sovCloud(uint64(m.FlowCount))
	}
	return n
}

func (m *CloudHierarchy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Region != 0 {
		n += 1 + sovCloud(uint64(m.Region))
	}
	if m.VPC != 0 {
		n += 1 + sovCloud(uint64(m.VPC))
	}
	if m.Subnet != 0 {
		n += 1 + sovCloud(uint64(m.Subnet))
	}
	if m.VMInstance != 0 {
		n += 1 + sovCloud(uint64(m.VMInstance))
	}
	l = len(m.RegionStr)
	if l > 0 {
		n += 1 + l + sovCloud(uint64(l))
	}
	l = len(m.VPCStr)
	if l > 0 {
		n += 1 + l + sovCloud(uint64(l))
	}
	l = len(m.SubnetStr)
	if l > 0 {
		n += 1 + l + sovCloud(uint64(l))
	}
	l = len(m.VMInstanceStr)
	if l > 0 {
		n += 1 + l + sovCloud(uint64(l))
	}
	return n
}

func (m *CloudTrafficSample) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowStartUnixSeconds != 0 {
		n += 1 + sovCloud(uint64(m.WindowStartUnixSeconds))
	}
	if m.WindowEndUnixSeconds != 0 {
		n += 1 + sovCloud(uint64(m.WindowEndUnixSeconds))
	}
	if m.CloudEntityType != 0 {
		n += 1 + sovCloud(uint64(m.CloudEntityType))
	}
	if m.SourceEntity != 0 {
		n += 1 + sovCloud(uint64(m.SourceEntity))
	}
	if len(m.ByteCounts) > 0 {
		for k, v := range m.ByteCounts {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovCloud(uint64(k)) + 1 + l + sovCloud(uint64(l))
			n += mapEntrySize + 1 + sovCloud(uint64(mapEntrySize))
		}
	}
	if len(m.LocalLookups) > 0 {
		for k, v := range m.LocalLookups {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCloud(uint64(k)) + 1 + len(v) + sovCloud(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloud(uint64(mapEntrySize))
		}
	}
	return n
}

func sovCloud(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCloud(x uint64) (n int) {
	return sovCloud(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ByteCount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ByteCount{`,
		`Out:` + fmt.Sprintf("%v", this.Out) + `,`,
		`In:` + fmt.Sprintf("%v", this.In) + `,`,
		`FlowCount:` + fmt.Sprintf("%v", this.FlowCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudHierarchy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudHierarchy{`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`VPC:` + fmt.Sprintf("%v", this.VPC) + `,`,
		`Subnet:` + fmt.Sprintf("%v", this.Subnet) + `,`,
		`VMInstance:` + fmt.Sprintf("%v", this.VMInstance) + `,`,
		`RegionStr:` + fmt.Sprintf("%v", this.RegionStr) + `,`,
		`VPCStr:` + fmt.Sprintf("%v", this.VPCStr) + `,`,
		`SubnetStr:` + fmt.Sprintf("%v", this.SubnetStr) + `,`,
		`VMInstanceStr:` + fmt.Sprintf("%v", this.VMInstanceStr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudTrafficSample) String() string {
	if this == nil {
		return "nil"
	}
	keysForByteCounts := make([]uint32, 0, len(this.ByteCounts))
	for k, _ := range this.ByteCounts {
		keysForByteCounts = append(keysForByteCounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForByteCounts)
	mapStringForByteCounts := "map[uint32]ByteCount{"
	for _, k := range keysForByteCounts {
		mapStringForByteCounts += fmt.Sprintf("%v: %v,", k, this.ByteCounts[k])
	}
	mapStringForByteCounts += "}"
	keysForLocalLookups := make([]uint32, 0, len(this.LocalLookups))
	for k, _ := range this.LocalLookups {
		keysForLocalLookups = append(keysForLocalLookups, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForLocalLookups)
	mapStringForLocalLookups := "map[uint32]string{"
	for _, k := range keysForLocalLookups {
		mapStringForLocalLookups += fmt.Sprintf("%v: %v,", k, this.LocalLookups[k])
	}
	mapStringForLocalLookups += "}"
	s := strings.Join([]string{`&CloudTrafficSample{`,
		`WindowStartUnixSeconds:` + fmt.Sprintf("%v", this.WindowStartUnixSeconds) + `,`,
		`WindowEndUnixSeconds:` + fmt.Sprintf("%v", this.WindowEndUnixSeconds) + `,`,
		`CloudEntityType:` + fmt.Sprintf("%v", this.CloudEntityType) + `,`,
		`SourceEntity:` + fmt.Sprintf("%v", this.SourceEntity) + `,`,
		`ByteCounts:` + mapStringForByteCounts + `,`,
		`LocalLookups:` + mapStringForLocalLookups + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCloud(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ByteCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByteCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByteCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			m.Out = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Out |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			m.In = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.In |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowCount", wireType)
			}
			m.FlowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloud
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudHierarchy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudHierarchy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudHierarchy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			m.Region = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Region |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPC", wireType)
			}
			m.VPC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VPC |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			m.Subnet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subnet |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VMInstance", wireType)
			}
			m.VMInstance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VMInstance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloud
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloud
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloud
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VMInstanceStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloud
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VMInstanceStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloud
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudTrafficSample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudTrafficSample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudTrafficSample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowStartUnixSeconds", wireType)
			}
			m.WindowStartUnixSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowStartUnixSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowEndUnixSeconds", wireType)
			}
			m.WindowEndUnixSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowEndUnixSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudEntityType", wireType)
			}
			m.CloudEntityType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudEntityType |= CloudEntityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceEntity", wireType)
			}
			m.SourceEntity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceEntity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloud
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloud
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ByteCounts == nil {
				m.ByteCounts = make(map[uint32]ByteCount)
			}
			var mapkey uint32
			mapvalue := &ByteCount{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloud
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloud
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloud
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloud
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloud
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ByteCount{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloud(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloud
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ByteCounts[mapkey] = *mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalLookups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloud
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloud
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalLookups == nil {
				m.LocalLookups = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloud
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloud
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloud
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloud
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloud
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloud(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloud
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LocalLookups[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloud
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCloud(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCloud
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloud
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCloud
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCloud
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCloud
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCloud        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCloud          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCloud = fmt.Errorf("proto: unexpected end of group")
)
